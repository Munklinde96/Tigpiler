(*User Declarations*)

%%

(*Parser Declarations*)
%term
    EOF 
  | ID of string
  | INT of int 
  | STRING of string 
  | COMMA | COLON | SEMICOLON | LPAREN | RPAREN | LBRACK | RBRACK 
  | LBRACE | RBRACE | DOT 
  | PLUS | MINUS | TIMES | DIVIDE | EQ | NEQ | LT | LE | GT | GE
  | AND | OR | ASSIGN
  | ARRAY | IF | THEN | ELSE | WHILE | FOR | TO | DO | LET | IN | END | OF 
  | BREAK | NIL
  | FUNCTION | VAR | TYPE 

%nonterm  exp | program | decs | dec | tydec | ty | tyfields | vardec 
  | fundec | lvalue 

%pos int
%verbose
%start program
%eop EOF
%noshift EOF

%name Tiger

%keyword WHILE FOR TO BREAK LET IN END FUNCTION VAR TYPE ARRAY IF THEN ELSE 
    DO OF NIL

%prefer THEN ELSE LPAREN

%value ID ("bogus")
%value INT (1)
%value STRING ("")

%%
(*Grammar Rules*)
(* This is a skeleton grammar file, meant to illustrate what kind of
 * declarations are necessary above the %% mark.  Students are expected
 *  to replace the two dummy productions below with an actual grammar. 
 *)

program:    stmlist               ()

stm:    ()

stmlist:    stm                   ()
        |   stmlist SEMICOLON stm ()

error:  ()
    
exp:                    ()
    |   lvalue          ()
    |   valueless expression ()
    |   NIL             ()
    |   exp SEMICOLON exp ()
    |   no value        ()
    |   INT             ()
    |   STRING          ()
    |   negation        ()
    |   function call   ()
    |   mathexp         ()
    |   compex      ()
    | string comparison ()
    |   boolean operator ()
    | precedence of operators ()
    | associativity of operatrs ()
    | record creation   ()
    | array creation    ()
    | array and record assignment   ()
    | extent    ()
    | assignment    ()
    | if then else  ()
    | if then ()
    | while ()
    | for ()
    | break ()
    | let ()
    | paren
    
mathexp:    exp PLUS exp    ()
    |       exp MINUS exp   ()
    |       exp TIMES exp   ()
    |       exp DIVIDE exp  ()

compexp:    exp EQ exp      ()
    |       exp NEQ exp     ()
    |       exp LT exp      ()
    |       exp LE exp      ()
    |       exp GT exp      ()
    |       exp GE exp      ()        
    
(*Declarations*)
decs:   {dec}           ()

dec:    tydec           ()
    |   vardec          ()
    |   fundec          ()
    
    
(*Data Types*)
tydec:  TYPE type-id = ty   ()

ty:     type-id         ()
    |   { tyfields }    ()
    |   ARRAY OF type-id  ()
    
tyfields:   (*empty*) ()
        |   ID : type-id {, ID : type-id}


(*Variables*)
vardec :    VAR ID := exp                               ()
        |   VAR ID : type-id := exp                     ()

(*Functions*)
fundec :    FUNCTION ID (tyfields) = exp                ()
        |   FUNCTION ID (tyfields) : type-id = exp      ()

(*L-Values*)
lvalue :    ID                                          ()
        |   lvalue . ID                                 ()
        |   lvalue [ exp ]                              ()
