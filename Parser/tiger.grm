(* User Declarations *)

%%

(* Parser Declarations *)
%term
    EOF 
  | ID of string
  | INT of int 
  | STRING of string 
  | COMMA | COLON | SEMICOLON | LPAREN | RPAREN | LBRACK | RBRACK 
  | LBRACE | RBRACE | DOT 
  | PLUS | MINUS | TIMES | DIVIDE | EQ | NEQ | LT | LE | GT | GE
  | AND | OR | ASSIGN
  | ARRAY | IF | THEN | ELSE | WHILE | FOR | TO | DO | LET | IN | END | OF 
  | BREAK | NIL
  | FUNCTION | VAR | TYPE 

%nonterm  exp | program | decs | dec | tydec | ty | tyfields | vardec 
  | fundec | lvalue 

%pos int
%verbose
%start program
%eop EOF
%noshift EOF

%name Tiger

%keyword WHILE FOR TO BREAK LET IN END FUNCTION VAR TYPE ARRAY IF THEN ELSE 
    DO OF NIL

%prefer THEN ELSE LPAREN

%value ID ("bogus")
%value INT (1)
%value STRING ("")

(* Precedence Directives *)
%nonassoc   EQ NEQ LT LE GT GE
%left       OR                  (* Binding - Loose *)
%left       AND                         (* | *)
%left       PLUS MINUS                  (* | *)
%left       TIMES DIVIDE                (* V *)
%left       UMINUS              (* Binding - Tight *)

%%
(* Grammar Rules *)
(* This is a skeleton grammar file, meant to illustrate what kind of
 * declarations are necessary above the %% mark.  Students are expected
 * to replace the two dummy productions below with an actual grammar. 
 *)

program:    exp         ()

error:  ()
    
exp:    functionCall    ()
    |   lvalue          ()
    |   mathexp         ()
    |   compexp         ()
    |   control         ()
    |   sequence        ()
    
    |   MINUS exp   %prec   UMINUS  () (* Unary Minus = Negative Sign *)
    
    |   NIL     ()
    |   INT     ()
    |   STRING  ()
    
sequence:           LPAREN sequenceExp RPAREN       ()
sequenceExp:        exp sequenceTail                ()
    |               (* empty *)                     ()
sequenceTail:       SEMICOLON exp sequenceTail      ()
    |               (* empty *)                     ()

functionCall:       ID LPAREN functionParam RPAREN  ()
functionParam:      exp functionParamTail           ()
    |               (* empty *)                     ()
functionParamTail:  COMMA exp functionParamTail     ()
    |               (* empty *)                     ()

(* Procedure calls, assignment, if-then, while, break, and sometimes 
 * if-then-else returns unit *)
 
control:    assignment                      () 
    |       IF exp THEN exp ELSE exp        ()
    |       IF exp THEN exp                 ()
    |       WHILE exp DO exp                ()
    |       FOR ID EQ exp TO exp DO exp     ()
    |       BREAK                           ()
    |       LET decs IN sequenceExp END     ()

mathexp:    exp PLUS exp    ()
    |       exp MINUS exp   ()
    |       exp TIMES exp   ()
    |       exp DIVIDE exp  ()

compexp:    exp EQ exp      ()
    |       exp NEQ exp     ()
    |       exp LT exp      ()
    |       exp LE exp      ()
    |       exp GT exp      ()
    |       exp GE exp      ()        

boolexp:    exp AND exp ()
    |       exp OR exp  ()

(* Declarations *)
decs:       dec decs        ()
    |       (* empty *)     ()

dec:        tydec           ()
    |       vardec          ()
    |       fundec          ()
    
(* Data Types *)
tydec:  TYPE type-id EQ ty                                              ()

ty:     type-id                                                         ()
    |   LBRACE tyfields RBRACE                                          ()
    |   ARRAY OF type-id                                                ()

tyfields:       ID COLON type-id LBRACE tyfieldsTail                    ()
    |           (* empty *)                                             ()
tyfieldsTail:   COMMA ID COLON type-id RBRACE tyfieldsTail              ()
    |           (* empty *)

(* Variables *)
vardec:     VAR ID ASSIGN exp                                           ()
    |       VAR ID COLON type-id ASSIGN exp                             ()

(* Functions *)
fundec:     FUNCTION ID LPAREN tyfields RPAREN EQ exp                   ()
    |       FUNCTION ID LPAREN tyfields RPAREN COLON type-id EQ exp     ()

(* L-Values *)
lvalue:     ID                                                          ()
    |       lvalue DOT ID                                               ()
    |       lvalue LBRACK exp RBRACK                                    ()