(* User Declarations *)
open Symbol
structure A = Absyn
%%

(* Parser Declarations *)
%term
    EOF 
  | ID of string
  | INT of int 
  | STRING of string 
  | COMMA | COLON | SEMICOLON | LPAREN | RPAREN | LBRACK | RBRACK 
  | LBRACE | RBRACE | DOT 
  | PLUS | MINUS | TIMES | DIVIDE | EQ | NEQ | LT | LE | GT | GE
  | AND | OR | ASSIGN
  | ARRAY | IF | THEN | ELSE | WHILE | FOR | TO | DO | LET | IN | END | OF 
  | BREAK | NIL
  | FUNCTION | VAR | TYPE 
  | UMINUS

%nonterm
      program of A.exp
    | exp of A.exp
    | functionCall  of A.exp
    | lvalue of A.exp
    | mathexp  of A.exp
    | boolexp of A.exp
    | compexp of A.exp
    | assignment  of A.exp
    | control of A.exp
    | sequence of A.exp
    | array of A.exp
    | record of A.exp

    | dec of A.dec
    | decs of A.dec list
    | vardec of A.dec
    | fundec of A.dec
    | tydec of A.dec
    
    | ty of A.ty

    | functionParam of A.exp list
    | functionParamTail of A.exp list
    | recordField of (symbol * A.exp * pos)
    | recordTail of (symbol * A.exp * pos) list
    | sequenceExp of (A.exp * pos) list
    | sequenceTail of (A.exp * pos) list
    | tyfields of {name: symbol, escape: bool ref, typ: A.ty, pos: pos} list
    | tyfieldsTail of {name: symbol, escape: bool ref, typ: A.ty, pos: pos} list

%pos int
%verbose
%start program
%eop EOF
%noshift EOF

%name Tiger

%keyword WHILE FOR TO BREAK LET IN END FUNCTION VAR TYPE ARRAY IF THEN ELSE 
    DO OF NIL

%prefer THEN ELSE LPAREN

%value ID ("bogus")
%value INT (1)
%value STRING ("")

(* Precedence Directives *)
%nonassoc   THEN DO                     (* Binding - Loose *)
%nonassoc   OF                                  (* | *)
%nonassoc   ASSIGN                              (* | *)
%right      ELSE                                (* | *)
%left       OR                                  (* | *)
%left       AND                                 (* | *)
%nonassoc   EQ NEQ LT LE GT GE                  (* | *)
%left       PLUS MINUS                          (* | *)
%left       TIMES DIVIDE                        (* V *)
%left       UMINUS                      (* Binding - Tight *)

%%
(* Grammar Rules *)

program:    exp         ()
    
exp:    functionCall    (functionCall)
    |   lvalue          (lvalue)
    |   mathexp         (mathexp)
    |   compexp         (compexp)
    |   boolexp         (boolexp)
    |   assignment      (assignment)
    |   control         (control)
    |   sequence        (sequence)
    |   array           (array)
    |   record          (record)
    
    |   MINUS exp   %prec   UMINUS  (A.OpExp {left=A.IntExp(0),oper=A.MinusOp,right=exp,pos=MINUSleft})
    
    |   NIL     (A.NilExp)
    |   INT     (A.IntExp(INT))
    |   STRING  (A.StringExp(STRING, STRINGleft))
    
array:              ID LBRACK exp RBRACK OF exp             (A.ArrayExp{typ=symbol ID,size=exp1,init=exp2,pos=IDleft})
recordField:        ID EQ exp                               ((symbol ID,exp,IDleft))
record:             ID LBRACE recordField recordTail RBRACE   (A.RecordExp {fields=[recordField] @ recordTail,typ=symbol ID1,pos=ID1left})
recordTail:         COMMA recordField recordTail              ([recordField] @ recordTail)
    |               (* empty *)                             (nil)
sequence:           LPAREN sequenceExp RPAREN               (A.SeqExp sequenceExp)
sequenceExp:        exp sequenceTail                        ([(exp,expleft)] @ sequenceTail)
    |               (* empty *)                             (nil)
sequenceTail:       SEMICOLON exp sequenceTail              ([(exp,expleft)] @ sequenceTail)
    |               (* empty *)                             (nil)

functionCall:       ID LPAREN functionParam RPAREN          (A.CallExp {func=symbol ID,args=functionParam,pos=IDleft})
functionParam:      exp functionParamTail                   ([exp] @ functionParamTail)
    |               (* empty *)                             (nil)
functionParamTail:  COMMA exp functionParamTail             ([exp] @ functionParamTail)
    |               (* empty *)                             (nil)

(* Procedure calls, assignment, if-then, while, break, and sometimes 
 * if-then-else returns unit *)
assignment: lvalue ASSIGN exp               (A.AssignExp {var=lvalue,exp=exp,pos=lvalueleft})
control:    IF exp THEN exp                 (A.IfExp {test=exp1,then'=exp2,else'=NONE,pos=IFleft})
    |       IF exp THEN exp ELSE exp        (A.IfExp {test=exp1,then'=exp2,else'=SOME exp3,pos=IFleft})
    |       WHILE exp DO exp                (A.WhileExp {test=exp1,body=exp2,pos=WHILEleft})
    |       FOR ID ASSIGN exp TO exp DO exp (A.ForExp {symbol=symbol ID,escape=ref false,lo=exp1,hi=exp2,body=exp3,pos=FORleft})
    |       BREAK                           (A.BreakExp(BREAKleft))
    |       LET decs IN sequenceExp END     (A.LetExp {decs=decs,body=A.SeqExp(sequenceExp,sequenceExpleft),pos=LETleft})
    
mathexp:    exp PLUS exp    (A.OpExp {left=exp1,oper=A.PlusOp,right=exp2,pos=exp1left})
    |       exp MINUS exp   (A.OpExp {left=exp1,oper=A.MinusOp,right=exp2,pos=exp1left})
    |       exp TIMES exp   (A.OpExp {left=exp1,oper=A.TimesOp,right=exp2,pos=exp1left})
    |       exp DIVIDE exp  (A.OpExp {left=exp1,oper=A.DivideOp,right=exp2,pos=exp1left})

compexp:    exp EQ exp      (A.OpExp {left=exp1,oper=A.EqOp,right=exp2,pos=exp1left})
    |       exp NEQ exp     (A.OpExp {left=exp1,oper=A.NeqOp,right=exp2,pos=exp1left})
    |       exp LT exp      (A.OpExp {left=exp1,oper=A.LtOp,right=exp2,pos=exp1left})
    |       exp LE exp      (A.OpExp {left=exp1,oper=A.LeOp,right=exp2,pos=exp1left})
    |       exp GT exp      (A.OpExp {left=exp1,oper=A.GtOp,right=exp2,pos=exp1left})
    |       exp GE exp      (A.OpExp {left=exp1,oper=A.GeOp,right=exp2,pos=exp1left})        

boolexp:    exp AND exp (A.IfExp {test=exp1,then'=exp2,else'=SOME(A.IntExp(0)),pos=exp1left})
    |       exp OR exp  (A.IfExp {test=exp1,then'=A.IntExp(1),else'=SOME exp2,pos=exp1left})

(* Declarations *)
decs:       dec decs        ([dec] @ decs)
    |       (* empty *)     (nil)

dec:        tydec           (A.TypeDec tydec)
    |       vardec          (A.VarDec vardec)
    |       fundec          (A.FunctionDec fundec)
    
(* Data Types *)
tydec:  TYPE ID EQ ty       ({name=symbol ID,ty=ty,pos=TYPEleft})

ty:     ID                      (A.NameTy(symbol ID,IDleft))
    |   LBRACE tyfields RBRACE  (A.RecordTy(tyfields))
    |   ARRAY OF ID             (A.ArrayTy(symbol ID,ARRAYleft))

tyfields:       ID COLON ID tyfieldsTail       ([{name=symbol ID1,escape=ref false,typ=ID2,pos=ID1left}] @ tyfieldsTail)
    |           (* empty *)                    (nil)
tyfieldsTail:   COMMA ID COLON ID tyfieldsTail ([{name=symbol ID1,escape=ref false,typ=ID2,pos=ID1left}] @ tyfieldsTail)
    |           (* empty *)                    (nil)

(* Variables *)
vardec:     VAR ID ASSIGN exp          ({name=symbol ID,escape=ref false,typ=NONE,init=exp,pos=VARleft})
    |       VAR ID COLON ID ASSIGN exp ({name=symbol ID1,escape=ref false,typ=SOME(symbol ID2,ID2left),init=exp,pos=VARleft})

(* Functions *)
fundec:     FUNCTION ID LPAREN tyfields RPAREN EQ exp              ({name=symbol ID,params=tyfields,result=NONE,body=exp,pos=FUNCTIONleft})
    |       FUNCTION ID LPAREN tyfields RPAREN COLON ID EQ exp     ({name=symbol ID1,params=tyfields,result=SOME(symbol ID2, ID2left),body=exp,pos=FUNCTIONleft})

(* L-Values *)
lvalue:     ID                         (A.SimpleVar(symbol ID, IDleft))
    |       lvalue DOT ID              (A.FieldVar(lvalue, symbol ID,lvalueleft))
    |       lvalue LBRACK exp RBRACK   (A.SubscriptVar(lvalue, exp, lvalueleft))
    |       ID LBRACK exp RBRACK       (A.SubscriptVar(A.SimpleVar(symbol ID,IDleft),exp,IDleft))